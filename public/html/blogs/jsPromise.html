<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" href="../../css/blogs.css">
    <title>js Promise异步执行</title>
</head>
<body>
<div class="container">
    <header>
        <h1 class="title">js Promise异步执行</h1>
        <div class="minTip">
            <span class="wordNum">字数</span>
            <span class="readNum">阅读量</span>
            <span class="likeNum">赞</span>
            <span class="likeNum">作者：MoHan</span>
        </div>
        <div class="means">
            <p>
                javascript异步编程, web2.0时代比较热门的编程方式，我们平时码的时候也或多或少用到，最典型的就是异步ajax，发送异步请求，绑定回调函数，
                请求响应之后调用指定的回调函数，没有阻塞其他代码的执行。还有像setTimeout方法同样也是异步执行回调的方法。
            </p>

        </div>
    </header>

    <section>
        <div class="method">
            <h2>Promise模式</h2>
            <p>
                promise采用的异步编程方式，很受大家的喜欢，因为它用起来很是方便，很痛快。在每次执行完一个异步任务后都会返回一个promise对象，
                使得我们在下次调用的时候能够使用它其中的then方法，then方法也会返回自身的promise对象以供下次调用
            </p>
            <p>
                ES6实现了promise,但是这里可以原生实现它，详情请看<a href="http://qingbob.com/promise-a-misunderstanding-and-practical/" target="_blank">Promise/A+</a>
            </p>
        </div>

        <div class="code">
            <h4>代码：</h4>
            <p>.js代码</p>
            <pre class="precode">
                <code>
    var callbacks = [];

    function Promise() {
        this.isPromise = true;
    }

    Promise.prototype = {
        resolve: function (result) {
            this.complete("resolve", result);
    },

    reject: function (result) {
        var _this = this;
        setTimeout(function () {
            _this.complete("reject", result);
        });
    },

    executeInLoop: function (promise,result) {
    // 如果队列里还有函数 并且（ 要么 没有返回一个值 或者 （有返回值但不是promise类型））
        if ((promise && !promise.isPromise || !promise) && callbacks.length) {

            var callback = this.getCallbackByType("resolve");

            if (callback) {
                var promise = callback(promise? promise: result);
                this.executeInLoop(promise, promise? promise: result);
            }
        }
    },

    getCallbackByType: function (type) {
        if (callbacks.length) {

        var callback = callbacks.shift()[type];

        while (!callback) {
            callback = callbacks.shift()[type];
        }

    }

        return callback;
    },

    complete: function (type, result) {

        var callback = this.getCallbackByType(type);

        if (callback) {
            var promise = callback(result);
        /*
        1. 有返回值，promise类型
        2. 有返回值，其他类型
        3. 无返回值
        */
            this.executeInLoop(promise, promise? promise: result);
        }
    },

    then: function (successHandler, failedHandler) {
        callbacks.push({
            resolve: successHandler,
            reject: failedHandler
        });

        return this;
        }
    }
    <p>
    测试：
    var delay = function (throwError) {
        var promise = new Promise();

        if (throwError) {
            promise.reject(new Error("ERROR"));
            return promise;
        }

        setTimeout(function () {
            promise.resolve("some data");
        }, 1000);

        return promise;
    }

    delay()
    // ------Level 1------
    .then(function FirstSucHandler(result) {
        console.log("First successHandler recevied: ", result);

        var p = new Promise();
        p.reject(new Error("This is a test"));
        return p;

    }, function FirstErrorHandler(error) {
        console.error("Second failedHandler catch: ", error);
    })
    // ------Level 2------
    .then(function SecondSucHandler(result) {
        console.log("Second successHandler recevied: ", result);
    })
    // ------Level 3------
    .then(function ThirdSucHandler(result) {
        console.log("Third successHandler recevied: ", result);
    }, function ThirdErrorHandler(error) {
        console.error("Third failedHandler catch: ", error);
    })
    // ------Level 4------
    .then(function FourSucHandler(result) {
        console.log("Fourth successHandler recevied: ", result);
    })


    输出：
    First successHandler recevied:  some data
    Third failedHandler catch:  Error: This is a test(…)
    Fourth successHandler recevied:  Error: This is a test(…)
    </p>
                </code>
            </pre>
            <h5>说明：</h5>
            <p>

            </p>
        </div>

        <!--<div class="explain">-->
        <!--点击<a href="../blogsDome/lazyLoadImgDome.html">这里</a>查看dome-->
        <!--</div>-->
    </section>

    <footer>
        <div class="like">
            <span>赞</span>
            <span></span>
        </div>
        <div class="github">
            <a href="https://github.com/fututer"><img src="../../images/github.svg" alt=""></a>
            <a href="javascript:void(0)"><img src="../../images/message1.svg" alt=""></a>
        </div>
    </footer>
</div>

<script src="../../assets/js/blogs/blogsCommon.js"></script>
<script src="../../assets/js/blogs/blogs.js"></script>
</body>
</html>